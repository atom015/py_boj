"""
문제
코레스코 콘도미니엄 8층은 학생들이 3끼의 식사를 해결하는 공간이다. 그러나 몇몇 비양심적인 학생들의 만행으로 음식물이 통로 중간 중간에 떨어져 있다. 이러한 음식물들은 근처에 있는 것끼리 뭉치게 돼서 큰 음식물 쓰레기가 된다.

이 문제를 출제한 선생님은 개인적으로 이러한 음식물을 실내화에 묻히는 것을 정말 진정으로 싫어한다. 참고로 우리가 구해야 할 답은 이 문제를 낸 조교를 맞추는 것이 아니다.

통로에 떨어진 음식물을 피해가기란 쉬운 일이 아니다. 따라서 선생님은 떨어진 음식물 중에 제일 큰 음식물만은 피해 가려고 한다.

선생님을 도와 제일 큰 음식물의 크기를 구해서 “10ra"를 외치지 않게 도와주자.

입력
첫째 줄에 통로의 세로 길이 N(1 ≤ N ≤ 100)과 가로 길이 M(1 ≤ M ≤ 100) 그리고 음식물 쓰레기의 개수 K(1 ≤ K ≤ 10,000)이 주어진다.  그리고 다음 K개의 줄에 음식물이 떨어진 좌표 (r, c)가 주어진다.

좌표 (r, c)의 r은 위에서부터, c는 왼쪽에서부터가 기준이다.

출력
첫째 줄에 음식물중 가장 큰 음식물의 크기를 출력하라.

예제 입력 1
3 4 5
3 2
2 2
3 1
2 3
1 1
예제 출력 1
4
힌트
# . . .
  . # # .
  # # . .
위와 같이 음식물이 떨어져있고 제일큰 음식물의 크기는 4가 된다. (인접한 것은 붙어서 크게 된다고 나와 있음. 대각선으로는 음식물 끼리 붙을수 없고 상하좌우로만 붙을수 있다.)
"""
import sys
sys.setrecursionlimit(50000) #재귀제한높이설정(이걸 기본값이상으로 안해주면 런타임에러가 난다.) ※기본값:1000
n,m,k = map(int,input().split()) #n:통로의세로길이,m:통로의가로길이,k:음식물쓰레기개수
li = [[0 for i in range(m)] for i in range(n)] #인접행렬을 가로길이:m,세로길이:n으로 만들어준다.
#상하좌우비교 리스트
dx = [0,0,-1,1]
dy = [1,-1,0,0]
compare = 0 #가장큰 음식물크기 비교 변수
#입력
for i in range(k):
    a,b = map(int,input().split())
    li[a-1][b-1] = 1
def dfs(x,y):
    global cnt
    cnt += 1 #음식물크기를 늘려준다.
    li[x][y] = 0 #방문체크
    #상하좌우
    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]
        if 0 <= nx < n and 0 <= ny < m: #nx,nx가 지도를 벗어나지않고
            if li[nx][ny] == 1: #방문한적이없으면
                dfs(nx,ny) #재귀를 돌린다.
    return cnt #cnt반환
for i in range(n):
    for j in range(m):
        if li[i][j] == 1:
            cnt = 0 #1이있을때마다 cnt를 초기화시켜준다.
            func = dfs(i,j) #func에 음식물크기를넣어준다.
            if compare < func: #만약에 func에들어있는값이 비교하는값에 들어있는값보다 클경우 서로 compare에 func를 넣어준다.
                compare = func
print(compare) #가장큰 음식물크기 출력
